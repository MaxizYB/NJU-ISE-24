# 第四章 指令系统

## 一、指令格式
### 1. 基本格式
#### 4.1.2 指令的基本格式
一条指令是机器语言的一个语句，是一组有意义的二进制代码，通常包括两部分：

| 操作码字段 | 地址码字段 |
| --- | --- |
| 指出该指令应执行的操作及功能（关键信息），例如：算术加/减、程序转移、返回等 | 给出被操作信息（指令或数据）的地址，包括：<br>- 参与运算的一个或多个操作数地址<br>- 运算结果的保存地址<br>- 程序转移地址<br>- 被调用子程序的入口地址等 |

#### 指令字长

- 定义：一条指令所包含的二进制代码的位数
- 取决于：操作码长度、地址码长度、地址码个数
- 与机器字长的关系：无固定关系，可等于、大于或小于机器字长
  - 字长指令：指令长度 = 机器字长
  - 半字长指令：指令长度 = 半个机器字长
  - 双字长指令：指令长度 = 两个机器字长
- 注意：指令长度影响取指令时间
  - 单字长指令：访存1次，1个存取周期
  - 双字长指令：访存2次，2个存取周期

#### 指令字结构

- 定长指令字结构：所有指令长度相等
  - 优点：执行速度快，控制简单
- 变长指令字结构：指令长度随功能不同而变化
  - 注意：主存按字节编址，指令字长通常为字节的整数倍

#### 指令格式分类（按地址码个数）
根据指令中操作数地址码的数目，分为：

- 零地址指令：操作码 + 无地址码
- 一地址指令：操作码 + 1个地址码
- 二地址指令：操作码 + 2个地址码
- 三地址指令：操作码 + 3个地址码

### 2. 操作码编码
#### （1）固定长度操作码

- 所有指令的操作码字段位数固定
- 优点：译码简单，速度快
- 缺点：指令字长有限时，指令种类较少

#### （2）扩展操作码（可变长度操作码）

- 目的：指令字长有限时，保持丰富的指令种类
- 原理：操作码长度随地址码的减少而增加（不同地址数的指令具有不同长度的操作码）
- 核心优势：有效缩短指令字长，兼顾指令种类和字长优化

#### 扩展操作码示例（指令字长16位）

| 指令类型 | 操作码位数 | 地址码字段 | 指令条数 | 扩展说明 |
| --- | --- | --- | --- | --- |
| 三地址指令 | 4位 | \(A_1\)（4位）、\(A_2\)（4位）、\(A_3\)（4位） | 15条 | 留1个编码（1111）用于扩展 |
| 二地址指令 | 8位（4+4） | \(A_1\)（4位）、\(A_2\)（4位） | 15条 | 前4位为1111，留1个编码（11111111）用于扩展 |
| 一地址指令 | 12位（8+4） | \(A_1\)（4位） | 15条 | 前8位为11111111，留1个编码用于扩展 |
| 零地址指令 | 16位（12+4） | 无 | 16条 | 前12位为111111111111 |

#### 扩展操作码设计规则

1. 不允许短码是长码的前缀（短操作码不能与长操作码的前面部分代码相同）
2. 各指令的操作码不可重复
3. 优化原则：使用频率高的指令分配较短操作码，降低译码和分析时间

### 3. 操作类型

1. 数据传送：load（加载）、save（保存）
2. 算术和逻辑运算
3. 移位操作
4. 转移操作：JMP（跳转）、Branch（分支）
5. 系统调用（自陷指令相关）
6. 其他：如中断相关操作

### 4. 寻址方式

| 寻址方式 | 有效地址（EA）计算 | 说明 |
| --- | --- | --- |
| 立即寻址 | EA = 指令中的立即数 | 直接操作指令中的立即数，无需访存 |
| 直接寻址 | EA = 指令中的直接地址 | 直接给出操作数在主存的地址 |
| 寄存器寻址 | EA = 寄存器编号 | 操作数存于寄存器，速度最快 |
| 寄存器间接寻址 | EA = 寄存器中的内容 | 寄存器中存放操作数的主存地址 |
| 变址寻址 | EA = (I) + A（I为变址寄存器） | 常用于数组、字符串等连续存储数据的访问 |
| 相对寻址 | EA = (PC) + A（PC为程序计数器） | 以当前指令地址为基准，偏移量为A，用于分支转移 |
| 基址寻址 | EA = (B) + A（B为基址寄存器） | 用于内存管理（如重定位），基址寄存器存放内存基地址 |

#### 基址寻址与变址寻址的区别

- 变址寻址：变址寄存器I内容可变，地址码A固定，侧重“偏移量固定，基址（I）可变”（如数组元素访问）
- 基址寻址：基址寄存器B内容固定（如内存分区基址），地址码A可变，侧重“基址固定，偏移量（A）可变”（如内存保护、重定位）

## 二、异常和中断
### 1. 核心区别

- 异常：CPU**内部**事件（执行指令过程中发生）
- 中断：CPU**外部**事件（I/O部件发起，与当前执行指令无关）
- 共性：处理过程基本相同，部分系统/教材统称“中断”或“异常”

### 2. 异常（Exception，又称例外）
#### 定义
处理器执行某条指令时，CPU内部发生的事件（如整除0、溢出、缺页等）

#### 分类及特点

| 类型 | 定义 | 处理后是否返回原指令 | 示例 |
| --- | --- | --- | --- |
| 故障（Fault，失效） | 执行指令过程中检测到的异常 | 部分可返回（如缺页），部分不可（如非法操作码） | 缺页、保护错、除数为0、非法操作码 |
| 自陷（Trap，陷阱） | 预先安排的“异常”事件（人为设置） | 是（返回自陷指令的下一条指令） | 单步跟踪、断点设置、系统调用指令、条件自陷指令 |
| 终止（Abort） | 严重错误导致程序无法继续执行 | 否 | DRAM/SRAM校验错、严重硬件故障 |

### 3. 中断（Interrupt）
#### 定义
程序执行过程中，外设完成任务或发生特殊事件时，向CPU发起的请求（如打印机缺纸、键盘缓冲满、定时采样结束）

#### 处理流程

1. 每条指令执行完毕后，CPU查询是否有中断请求
2. 若有，保存断点（下条指令地址）到栈或寄存器
3. 转入中断服务程序执行
4. 服务程序结束后，恢复断点，返回原程序继续执行

#### 关键说明

- 又称I/O中断或外部中断
- 需通过专门的中断请求线向CPU发起请求

### 4. ISA的相关规定

指令集架构（ISA）需明确：

- 异常/中断类型定义
- 自陷指令规范
- 中断允许位设置
- 异常/中断原因的识别与记录
- 断点信息保存方式
- 软硬件协同处理机制

## 三、MIPS指令格式与寻址
### 1. 核心特性

- 典型RISC处理器，采用32位**定长指令字**
- 操作码字段固定长度，无专门寻址方式字段（由指令格式确定寻址方式）
- 指令格式仅3种：R-型、I-型、J-型

### 2. MIPS指令格式（32位）
#### （a）R-型指令（寄存器型）

| 31-26 | 25-21 | 20-16 | 15-11 | 10-6 | 5-0 |
| --- | --- | --- | --- | --- | --- |
| OP（操作码，6位） | rs（源寄存器1，5位） | rt（源寄存器2，5位） | rd（目的寄存器，5位） | shamt（移位量，5位） | func（功能码，6位） |

#### （b）I-型指令（立即数型）

| 31-26 | 25-21 | 20-16 | 15-0 |
| --- | --- | --- | --- |
| OP（操作码，6位） | rs（源寄存器，5位） | rt（目的寄存器，5位） | 立即数（16位） |

#### （c）J-型指令（跳转型）

| 31-26 | 25-0 |
| --- | --- |
| OP（操作码，6位） | 直接地址（26位） |

### 3. 大端（文档中“大瑞”修正）
MIPS支持大端存储模式（数据的高位字节存于低地址，低位字节存于高地址）

## 四、选择与循环结构汇编

### 一、选择分支结构（if/if-else）
核心逻辑：通过「比较指令（slt/sltu）+ 分支指令（beq/bne）」控制执行流，无关键字直接支持，依赖跳转实现。

#### 1. 单分支if
**C代码示例**

```c
// 若a < b，c = a + b
int if_demo(int a, int b) {
    int c = 0;
    if (a < b) c = a + b;
    return c;
}
```

**简洁MIPS汇编**
```mips
if_demo:
    li      $t0, 0          # c=0
    slt     $t1, $a0, $a1   # a<b则$t1=1
    beq     $t1, $zero, ret # 不成立则跳至返回
    add     $t0, $a0, $a1   # 成立执行c=a+b
ret:
    move    $v0, $t0
    jr      $ra
```

#### 2. 双分支if-else
**C代码示例**
```c
// 若x≥y，max=x；否则max=y
int if_else_demo(int x, int y) {
    return x >= y ? x : y;
}
```

**简洁MIPS汇编**
```mips
if_else_demo:
    slt     $t0, $a0, $a1   # x<y则$t0=1
    bne     $t0, $zero, else# 成立跳至else
    move    $v0, $a0        # if：max=x
    j       ret
else:
    move    $v0, $a1        # else：max=y
ret:
    jr      $ra
```

### 二、循环结构（while/do-while/for）
核心逻辑：「条件判断→循环体→变量更新」闭环，通过分支指令控制循环退出/继续。

#### 1. while循环（先判断后执行）
**C代码示例**
```c
// 1~n累加和
int while_demo(int n) {
    int sum=0, i=1;
    while(i <= n) { sum += i; i++; }
    return sum;
}
```

**简洁MIPS汇编**
```mips
while_demo:
    li      $t0, 0          # sum=0
    li      $t1, 1          # i=1
cond:
    slt     $t2, $a0, $t1   # n<i则$t2=1
    bne     $t2, $zero, ret # 不成立退出
    add     $t0, $t0, $t1   # sum+=i
    addi    $t1, $t1, 1     # i++
    j       cond
ret:
    move    $v0, $t0
    jr      $ra
```

#### 2. do-while循环（先执行后判断）
**C代码示例**
```c
// 1~n乘积
int do_while_demo(int n) {
    int prod=1, i=1;
    do { prod *= i; i++; } while(i <= n);
    return prod;
}
```

**简洁MIPS汇编**
```mips
do_while_demo:
    li      $t0, 1          # prod=1
    li      $t1, 1          # i=1
body:
    mul     $t0, $t0, $t1   # prod*=i
    addi    $t1, $t1, 1     # i++
    slt     $t2, $a0, $t1   # n<i则$t2=1
    beq     $t2, $zero, body# 成立继续循环
    move    $v0, $t0
    jr      $ra
```

#### 3. for循环（初始化+判断+更新一体化）
**C代码示例**
```c
// n的阶乘（n≥0）
int for_demo(int n) {
    int fact=1;
    for(int i=1; i<=n; i++) fact *= i;
    return fact;
}
```

**简洁MIPS汇编**
```mips
for_demo:
    li      $t0, 1          # fact=1
    li      $t1, 1          # i=1
cond:
    slt     $t2, $a0, $t1   # n<i则$t2=1
    bne     $t2, $zero, ret # 不成立退出
    mul     $t0, $t0, $t1   # fact*=i
    addi    $t1, $t1, 1     # i++
    j       cond
ret:
    move    $v0, $t0
    jr      $ra
```

### 核心指令总结

| 指令       | 功能                     | 核心用途               |
|------------|--------------------------|------------------------|
| slt/sltu   | 有符号/无符号比较（<）   | 条件判断，转化逻辑为0/1 |
| beq/bne    | 相等/不等分支跳转        | 控制执行流转移         |
| add/addi/mul | 加减乘运算             | 变量更新、循环体计算   |
| j          | 无条件跳转               | 回到条件判断或退出点   |

## 五、过程调用
### 1. 预备知识
#### （1）jal指令的作用

- 功能1：将返回地址（调用指令的下一条指令地址）自动存入$ra寄存器（$31）
- 功能2：将控制转移到被调用过程的入口地址

#### （2）寄存器规则（MIPS寄存器使用规范）
| 寄存器组 | 用途 | 保存责任 |
| --- | --- | --- |
| $a0~$a3 | 传递前4个非浮点数入口参数 | 调用者（P）保存（若返回后需使用） |
| $v0~$v1 | 传递非浮点数返回参数 | 被调用者（Q）设置后返回 |
| $ra（$31） | 存放返回地址 | jal指令自动设置，被调用者（Q）需保存（若Q调用其他过程） |
| $s0~$s7（保存寄存器） | 过程返回后仍需使用的变量 | 被调用者（Q）保存（使用前压栈，返回前恢复） |
| $t0~$t9（临时寄存器） | 临时使用的变量 | 调用者（P）保存（若需保留），被调用者（Q）可自由使用 |

#### （3）MIPS栈与栈帧（Stack Frame）

- 栈增长方向：高地址 → 低地址
- 栈帧定义：每个过程独占的栈区，由帧指针$fp和栈指针$sp界定
    - 帧指针$fp：固定指向当前栈帧的起始位置（便于访问栈中变量）
    - 栈指针$sp：动态移动（数据入栈时$sp递减，出栈时递增）
- 栈帧组成（从高地址到低地址）：
    1. 临时寄存器（$t0~$t9）（必要时保存）
    2. 参数寄存器（$a0~$a3）（必要时保存）
    3. 其余输入参数（超过4个时，压栈）
    4. 返回地址$ra（嵌套调用时保存）
    5. 保存寄存器（$s0~$s7）（被调用者保存）
    6. 局部变量（寄存器溢出或复杂类型如数组、结构）
- 特殊情况：若当前过程无局部变量，编译器可省略$fp的设置与恢复（减少开销）
- $fp初始值：通常为调用时的$sp或$sp-4（指向当前栈帧前一个字或第一个字起始位置）

### 2. MIPS过程调用协议
#### （1）调用过程P的执行步骤（调用前）

1. 保存寄存器：若P返回后需使用$a0~$a3、$t0~$t9，将其压入当前栈帧（调用者保存）
2. 传递参数：前4个参数送入$a0~$a3，其余参数压入当前栈帧
3. 执行jal指令：保存返回地址到$ra，控制转移到被调用过程Q

#### （2）被调用过程Q的执行步骤（三段式）
##### ① 开始段（栈帧生成、寄存器保存、局部变量申请）

1. 申请栈帧：调整$sp（$sp = $sp - 栈帧大小）
2. 保存关键寄存器：若Q需调用其他过程，将$ra和$fp压入当前栈帧
3. 设置$fp：$fp = $sp + 栈帧大小（固定栈帧起始位置）
4. 保存保存寄存器：若Q使用$s0~$s7，将其压入当前栈帧
5. 分配局部变量空间：
   - 寄存器溢出时，在栈帧中分配
   - 复杂类型（数组、结构）在栈帧中分配
6. 栈帧大小：至少等于上述所有存储单元的总和

##### ② 本体段（过程体）

- 执行过程的核心逻辑（具体功能实现）

##### ③ 结尾段（寄存器恢复、栈帧释放、返回）

1. 恢复保存寄存器：将$sp栈帧中保存的$s0~$s7值恢复到对应寄存器
2. 恢复$ra和$fp：若已保存，分别恢复到$ra和$fp
3. 释放栈帧：调整$sp（$sp = $sp + 栈帧大小 或 $sp = $fp）
4. 返回调用过程：执行jr $ra指令（将控制权返还给P）

#### （3）栈帧生命周期

- 调用过程P和被调用过程Q的栈帧在调用期间共存，Q返回后，其栈帧被释放（$sp恢复到调用前位置）