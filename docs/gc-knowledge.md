# C++总复习

## 2. 对象与类

### 2.1 对象与类的基本定义

**对象**：类的实例，是具有属性（数据成员）和行为（成员函数）的具体实体。

**类**：对象的抽象模板，定义了对象共有的数据成员和成员函数，规定了对象的属性和行为。

**成员访问修饰符**：

- `public`：公有权限，类内外均可访问。
- `private`：私有权限，仅类内（含友元）可访问。
- `protected`：保护权限，类内（含友元）及子类可访问。

**对象的创建与销毁**：

- 创建动态数组对象：`A* p = new A[100];`（分配100个A类对象的连续内存）。
- 销毁动态数组对象：`delete[] p;`（必须用`delete[]`匹配`new[]`，避免内存泄漏）。

**成员对象**：一个类的成员可以是另一个类的对象（嵌套对象），称为成员对象。

**对象的操作机制**：对象的行为通过向对象发送消息（调用成员函数）实现。

### 2.2 this指针

**核心特性**：

- 每个非静态成员函数都隐含一个`this`指针参数，指向当前调用该函数的对象。
- 数据成员为每个对象单独拥有拷贝；静态成员函数无`this`指针，所有对象共享，仅能访问静态成员。

**this指针的使用场景**：

- 区分成员变量与局部变量（如`this->x = x`）。
- 从成员函数中返回当前对象（`return *this`）。
- 作为参数传递给其他函数（传递当前对象的地址）。

### 2.3 构造函数与析构函数

**构造函数的基本规则**：

- 函数名与类名相同，无返回值（无需写`void`）。
- C++11前不允许在类内直接初始化数据成员（如`int x=0;`不允许），需通过构造函数或初始化表赋值。

**默认构造函数**：

- 无参数或所有参数都有默认值的构造函数（如`A()`、`A(int a=0)`）。
- 若未自定义构造函数，编译器会自动生成默认构造函数；若自定义了任意构造函数，编译器不再生成。
- 调用方式：`A a1;`（无参）、`A a2 = A();`（显式无参）、`new A`（动态对象）、`new A(2)`（带参构造）。

**常成员与引用成员的初始化**：

- `const`修饰的常数据成员、引用数据成员，不能在声明时初始化，也不能在构造函数体内部赋值。
- 必须在**成员初始化表**中完成初始化（如`A(const int& val) : x(val), ref(val) {}`）。

**成员初始化表的注意事项**：

- 初始化顺序不依赖初始化表中的书写顺序，最终由数据成员在类中的**声明顺序**决定。
- 语法格式：`类名(参数列表) : 成员1(初值1), 成员2(初值2), ... {}`。

**析构函数**：

- 函数名前加`~`，与类名相同，无参数、无返回值，一个类仅有一个析构函数。
- 核心作用：释放对象生命周期中额外申请的资源（如动态内存、文件句柄等）。
- 可主动调用（如`a.~A();`），此时暂时归还资源，但对象未被销毁，生命周期仍持续到作用域结束。

**成员对象的初始化与销毁次序**：

- 初始化：先调用**成员对象的构造函数**（按成员对象在本类中的声明顺序），再执行本类的构造函数体。
- 销毁：先执行本类的析构函数体，再调用**成员对象的析构函数**（按成员对象声明顺序的逆序）。

### 2.4 对象的拷贝与转移初始化

#### 拷贝构造函数

**定义格式**：`A(const A& a)`（参数为同类对象的常量引用，避免递归调用）。

**三种调用时机**：

- 创建对象时，显式用另一个同类对象初始化：`A a2(a1);` 或 `A a2 = a1;`。
- 对象作为**值参数**传递给函数：`void f(A x)`（调用`f(a1)`时，用`a1`拷贝构造`x`）。
- 函数返回值为对象（值返回）：`A f() { A temp; return temp; }`（用`temp`拷贝构造返回的临时对象）。

**隐式拷贝构造函数**：

- 若未自定义拷贝构造函数，编译器会自动生成隐式拷贝构造函数。
- 对非成员对象：按字节拷贝（浅拷贝）数据成员。
- 对成员对象：调用成员对象的拷贝构造函数完成初始化。

**浅拷贝的问题**：

- 当类包含指针成员时，浅拷贝仅复制指针地址，而非指针指向的资源。
- 导致多个对象共享同一块资源，析构时会重复释放，引发内存泄漏或程序崩溃。

**深拷贝**：

- 自定义拷贝构造函数，为指针成员重新分配内存，并复制资源内容（如`A(const A& a) { this->ptr = new int(*a.ptr); }`）。
- 解决浅拷贝的资源共享问题，确保每个对象拥有独立的资源。

**自定义拷贝构造函数的注意事项**：

- 自定义拷贝构造函数不会自动调用成员对象的拷贝构造函数。
- 必须在自定义拷贝构造函数的**成员初始化表中显式指定**（如`A(const A& a) : member(a.member) {}`）。

**拷贝构造函数的潜在问题**：

- 当用一个即将被销毁的临时对象初始化另一个同类对象时，自定义拷贝构造函数的效率较低（需拷贝资源）。

**返回值优化（RVO）**：

- 编译器优化技术，针对"函数值返回对象"的场景（第三种调用时机）。
- 直接在调用者的栈帧中创建目标对象，避免临时对象的创建和拷贝，提升效率。
- 优化后不执行拷贝构造函数，直接将函数内的对象资源转移到调用者对象中。

**移动构造函数**：

- 解决临时对象拷贝效率低的问题，语法格式：`A(A&& a)`（参数为右值引用）。
- 编译器不会提供隐式移动构造函数，需手动定义。
- 核心逻辑："窃取"右值对象（临时对象）的资源，而非拷贝，右值对象后续会被析构，不影响程序安全。

**关键工具与概念**：

- `std::move`：将左值转换为右值引用，使左值对象可被移动构造函数使用（如`A a2 = std::move(a1);`）。
- 左值vs右值：左值是可取地址、能被赋值的对象（如变量`a1`）；右值是临时对象、字面量（如`A()`、`10`），不可取地址。

### 2.5 常成员与静态成员

#### 常成员

**常成员函数**：

- 声明格式：`返回值类型 函数名(参数列表) const;`（`const`在函数名后）。
- 核心限制：不能修改类的非静态数据成员，也不能调用非`const`的成员函数。
- 常对象（`const A a;`）只能调用类中的常成员函数；非`const`对象既可调用常成员函数，也可调用非`const`成员函数。

**常数据成员**：

- 声明格式：`const 数据类型 成员名;`（如`const int x;`）。
- 必须在成员初始化表中初始化，初始化后不可修改。

#### 静态成员

**静态数据成员**：

- 声明格式：`static 数据类型 成员名;`（类内声明）。
- 必须在**类外定义并初始化**（类外定义时不加`static`，需加类名限定符），如`int A::count = 0;`。
- 所有对象共享该成员，生命周期与程序一致（早于对象创建，晚于对象销毁）。

**静态成员函数**：

- 声明格式：`static 返回值类型 函数名(参数列表);`。
- 无`this`指针，仅能访问类的静态成员（静态数据成员、静态成员函数），不能访问非静态成员。
- 调用方式：`类名::函数名()`（推荐）或`对象.函数名()`。

### 2.6 友元

**定义与作用**：

- 友元是类授予的一种特殊访问权限，被声明为友元的实体（函数、类）可访问类的`private`和`protected`成员。
- 声明格式：在类内用`friend`关键字声明（如`friend void f(A& a);`、`friend class B;`）。

**友元的特性**：

- 友元关系是单向的（A是B的友元，不代表B是A的友元）。
- 友元关系不可传递（A是B的友元，B是C的友元，不代表A是C的友元）。
- 友元不具有继承性（子类不会继承父类的友元关系）。

### 2.7 类作为模块

**模块的定义**：类是面向对象中的基本模块，封装了数据（属性）和操作（行为），实现"高内聚、低耦合"。

**类结构与子结构**：类的结构直接对应模块的结构，成员对象可视为模块的子模块。

**良好的面向对象程序设计风格**：

- 减少类之间的关联度（低耦合），类内部高度聚合（高内聚）。
- 迪米特法则（Demeter's Law）：一个类的成员函数只能访问以下对象：
  - 自身对象（`this`指向的对象）。
  - 函数参数传递的对象。
  - 成员对象。
  - 函数内创建的局部对象。
  - 仅应向上述有限集合中的对象发送消息（调用成员函数），避免过度依赖其他对象。

## 3. 操作符重载

### 3.1 操作符重载的基本规则

**定义格式**：

- 成员函数形式：`返回值类型 operator操作符(参数列表) const;`（如`A operator+(const A& x) const;`）。
- 全局函数形式：`friend 返回值类型 operator操作符(参数列表);`（需声明为友元以访问类私有成员）。

**重载限制**：

- 不能重载的操作符：`.`、`.*`、`::`、`? :`、`sizeof`、`typeid`等。
- 作为全局函数重载时，至少有一个参数是类、结构、枚举或其引用（避免重载基本数据类型的操作符，如`int+int`）。
- 运算符`+=`等复合赋值运算符，建议用成员函数重载；`+`等二元运算符，可根据需求选择成员函数或全局函数。

**下标操作符`[]`重载**：

- 需重载两个版本（支持普通对象和常对象）：
  - 普通版本：`int& operator[](int i);`（可修改对象成员）。
  - 常版本：`int operator[](int i) const;`（常对象调用，不可修改）。

**单目操作符重载**：

- 负号`-`重载（成员函数形式）：`A operator-() const;`（如`A b = -a;`）。

**自增`++`与自减`--`重载**：

- 前置版本（无参数）：`A& operator++();`（返回引用，支持链式操作，如`++(++a)`）。
- 后置版本（参数为`int`，仅作为区分标记）：`const A operator++(int);`（返回临时对象，不支持链式自增，如`(a++)++`无效）。

**自定义类型转换操作符**：

- 定义格式：`operator 目标类型() const;`（如`operator int() const;`，支持`A a; int x = a;`的隐式转换）。

**`explicit`关键字**：

- 用于修饰单参数构造函数或类型转换操作符，禁止隐式类型转换。
- 示例：`explicit A(int x) {}`（禁止`A a = 5;`，仅允许`A a(5);`显式构造）；`explicit operator int() const;`（禁止`int x = a;`，仅允许`int x = static_cast<int>(a);`显式转换）。

### 3.2 赋值操作符重载

**核心问题**：与浅拷贝类似，若类包含指针成员，默认赋值操作符（编译器自动生成）会执行浅拷贝，导致资源共享问题。

**自定义赋值操作符的注意事项**：

- 若类包含成员对象，自定义赋值操作符不会自动调用成员对象的赋值操作符，需显式调用（如`this->member = a.member;`）。
- 需处理自赋值情况（`a = a;`），避免资源释放后再访问（如`delete ptr; ptr = new int(*a.ptr);`前需判断`this != &a`）。

**拷贝与赋值的区别**：

- 拷贝：创建新对象时用已有对象初始化（调用拷贝构造函数），如`A b = a;`、`A b(a);`。
- 赋值：已有对象之间的赋值操作（调用赋值操作符），如`A b; b = a;`。

**移动赋值操作符**：

- 定义格式：`A& operator=(A&& a);`（参数为右值引用）。
- 核心逻辑：窃取右值对象的资源，避免拷贝，提升效率（如`A b = std::move(a);`）。

### 3.3 函数对象（仿函数）

**定义**：重载了`()`操作符的类的对象，具备函数调用的特性。

**核心原理**：`()`的重载本质是操作符重载，函数对象的调用其实是调用`operator()`。

**使用场景**：

- 作为算法的参数（如STL算法`sort`的比较函数）。
- 封装带状态的函数逻辑（函数对象可包含数据成员，记录状态）。

**实现步骤**：

- 定义一个类，重载`operator()`成员函数（参数对应函数的参数，返回值对应函数的返回值）。
- 创建该类的对象（普通对象或临时对象）。
- 用"对象名(参数列表)"的形式调用（如`MyFunc f; f(10);`或`MyFunc()(10);`）。

**示例场景**：

- 定义一个类，数据成员对应表达式中用到的环境变量（如系数、阈值等）。
- 重载`()`操作符，实现表达式计算逻辑（如`class Add { int val; public: Add(int v) : val(v) {} int operator()(int x) { return x + val; } };`）。
- 创建临时对象并调用：`int res = Add(5)(3);`（结果为8）。

**lambda表达式**：

- 本质上也是使用函数对象实现的，具体可参见ppt

### 3.4 智能指针与new/delete重载
#### 智能指针

1. 核心作用：通过智能指针访问所指向对象时，可附加额外操作，核心功能是管理对象空间的自动回收；
2. 好处：避免内存泄漏，简化动态内存管理；
3. 常见类型：`shared_ptr`（共享所有权）、`unique_ptr`（独占所有权）；
4. 自定义智能指针：需封装原始指针，在析构函数中实现内存自动释放逻辑。

#### new/delete重载
1. `new`和`delete`可作为类的静态成员函数重载（`static`关键字可省略）；
2. 重载格式：
      - 单个对象：`void operator new(size_t size)`、`void operator delete(void* p, size_t size)`；
      - 数组对象：`void operator new[](size_t size)`、`void operator delete[](void* p, size_t size)`；
3. 作用：自定义内存分配/释放逻辑（如内存池、日志记录）。

## 4. 继承与派生

### 4.1 继承-派生类
1. 代码复用：将已有类的功能直接复用，在新类中扩展或修改功能，实现方式包括继承和组合；
2. 继承的定义：定义新类时，吸收一个或多个已有类（基类）的全部功能，再新增或修改功能，分为单继承（一个直接基类）和多继承（多个直接基类）；
3. 继承的作用：代码复用、实现层次结构、支持组合、增量开发；
4. 单继承要点：

      - 定义派生类需遵循基类定义规范；
      - `protected`权限：解决封装与继承的矛盾，基类`protected`成员可被派生类访问，类外不可访问；
      - 派生类成员作用域：嵌套在基类作用域中；同名成员会发生基类隐藏，需用“基类名::成员名”限定访问；即使参数列表不同（如`f(int)`与`f()`），因作用域不同，仍为隐藏而非重载；
5. 继承方式（访问权限控制）：同单继承规则，派生类成员访问权限由基类成员权限和继承方式共同决定，权限只能缩小不能放大；
6. public继承与子类型：public继承的派生类可视为基类的子类型，在需要基类对象的地方可替换为派生类对象；
7. 派生类对象的初始化与析构：

      - 基类成员由基类构造函数初始化，派生类自身成员由派生类构造函数初始化；
      - 初始化顺序：基类构造函数 → 成员对象构造函数 → 派生类构造函数；
      - 析构顺序：与初始化顺序相反（派生类析构函数 → 成员对象析构函数 → 基类析构函数）；
8. 派生类的构造与赋值：派生类构造函数需显式调用基类构造函数（若基类无默认构造函数）；赋值时需手动调用基类赋值运算符，避免基类成员赋值遗漏。

### 4.2 虚函数与消息的动态绑定
1. 静态绑定：默认情况下，编译时刻根据指针/引用的类型决定调用哪个函数，继承下默认按此方式绑定；
2. 动态绑定：需在基类中用虚函数指定，根据对象实际类型决定调用的函数；
3. 虚函数：用`virtual`修饰的成员函数，支持动态绑定，基类中声明后，派生类可重定义（`override`）；

   - 核心要求：签名（函数名、参数列表、const属性）需完全相同，返回值类型需一致（或协变）；`final`关键字可禁止派生类重定义该虚函数，或禁止类被继承；
   - 关键说明：

     - 仅非静态成员函数可作为虚函数，静态成员函数无`this`指针，不能是虚函数；
     - 构造函数不能是虚函数，析构函数通常声明为虚函数（避免删除派生类对象时内存泄漏）；
     - 基类声明`virtual`后，派生类同签名成员函数默认是虚函数，可省略`virtual`；
     - 仅通过基类指针或引用访问虚函数时，才触发动态绑定；
     - 基类构造函数/析构函数中调用虚函数，不触发动态绑定（构造时派生类未初始化，析构时派生类已部分销毁，访问派生类虚函数会出错）；
4. 基类指针访问派生类新成员：需通过`dynamic_cast`强制类型转换，转换失败返回`nullptr`（指针）或抛出异常（引用），示例：`B2* y = dynamic_cast<B2*>(p); if (y != nullptr) { ... }`；
5. 动态绑定的实现原理：

      - 虚函数表（vtable）：每个包含虚函数的类（基类/派生类）编译期生成全局只读数组，存储虚函数地址；派生类vtable继承自基类，重定义的虚函数替换对应地址，新增虚函数追加到尾部；无虚函数的类无vtable；
      - 虚指针（vptr）：包含虚函数的类的对象中，编译器自动添加的隐含成员（作为第一个成员），占用一个指针的内存空间（32位4字节，64位8字节）；vptr在构造函数执行时初始化，指向当前类的vtable。

### 4.3 纯虚函数和抽象类
1. 纯虚函数定义：`virtual int f() = 0;`，仅声明接口，无实现；
2. 抽象类：包含纯虚函数的类，核心作用是定义接口规范；
3. 关键规则：派生类必须实现基类的所有纯虚函数，否则派生类仍为抽象类；抽象类不能创建对象（仅用于继承）。

### 4.4 多继承
1. 定义：派生类可以有一个以上的直接基类，派生类拥有所有基类的全部成员；
2. 定义格式：`class <派生类名> : [<继承方式>]<基类名1>, [<继承方式>]<基类名2>, ... { <成员说明表> };`，继承方式及访问控制同单继承；
3. 基类声明次序：决定派生类对象中基类数据成员的存储安排；
4. 指针/引用访问规则：

      - public多继承的派生类与各基类是子类型关系，基类指针/引用可指向/引用派生类对象；
      - 派生类对象地址赋给基类指针时，编译器自动进行地址调整；
      - 示例：`C c; A* pa = &c; c.fa(); --> A::fa(this); B* pb = &c; c.fb(); --> B::fb(this);`；通过`pa`仅能访问A类和C类内容，通过`pb`仅能访问B类和C类内容，访问C类新增内容需通过虚函数动态绑定；
5. 常见问题及解决方案：

      - 名冲突：多个基类有同名成员（如A和B都有`f()`），派生类访问时需用基类名限定（`A::f()`、`B::f()`）；
      - 重复继承：多个基类继承自同一间接基类，导致成员重复存储；解决方案是将间接基类声明为虚基类（`class B : virtual public A { ... }`）；
6. 虚基类构造函数：调用优先级高于非虚基类构造函数，由最终派生类直接调用，而非中间基类。

## 5. 聚合与组合
1. 继承的关系是“is-a”（派生类是基类的一种），聚合与组合的关系是“has-a”（一个类包含另一个类）；
2. 核心区别：

      - 聚合：A类对象创建/销毁时，B类对象可独立存在（可脱离A），通常用对象指针实现；
      - 组合：B类对象随A类对象创建而创建、销毁而销毁（不可脱离A），通常用直接对象成员实现；
3. 子类型关系：public继承的派生类具备基类的子类型关系，聚合/组合关系的类无此关系。

## 6. 输入/输出（I/O）
1. C++的I/O并非语言内置特性，而是由标准库实现；
2. 缓冲区机制：输出时数据先存入内存缓冲区，缓冲区满/手动刷新/程序结束时写入外设；输入时数据先读入输入缓冲区，程序从缓冲区读取；
3. C++ I/O的核心：通过重载`<<`和`>>`运算符，支持自定义类对象的输入输出；
4. I/O分类：

      - 控制台I/O：核心对象包括`cin`（istream类，标准输入）、`cout`（ostream类，标准输出）、`cerr`/`clog`（ostream类，标准错误/日志输出）；
      - 输出格式设置：通过操眷实现，包括`hex`（十六进制）、`oct`（八进制）、`dec`（十进制）、`flush`（刷新缓冲区）、`setprecision`（精度）、`scientific`（科学计数法）、`fixed`（固定小数位）；
      - 文件I/O：
        - 存储方式：文本方式和二进制方式，文本方式读写兼容性好，二进制方式读写效率高；
        - 读写过程：打开（读/写模式）→ 读写 → 关闭；
        - 代码举例（流式文件）：
          ```cpp
          // 写文件
          ofstream outFile("test.txt", ios::out);
          outFile << "Hello File I/O";
          outFile.close();
          // 读文件
          ifstream inFile("test.txt", ios::in);
          string content;
          inFile >> content;
          inFile.close();
          ```
5. 文件随机存取：通过`seekg()`（调整输入流指针）、`seekp()`（调整输出流指针）、`tellg()`/`tellp()`（获取指针位置）实现，基准位置包括`ios::beg`（文件开头）、`ios::cur`（当前位置）、`ios::end`（文件末尾）。

## 7. 异常处理与断言
### 异常处理（exception handling）
1. 定义：处理程序运行时错误（如除零、文件打开失败）的机制，核心关键字`try`、`throw`、`catch`；
2. 基本流程：

      - `try`块包裹可能抛出异常的代码，其后可跟多个`catch`块；
      - 无异常时，跳过`catch`块，执行后续代码；
      - 抛出异常时，查找匹配的`catch`块（类型精确匹配），执行处理逻辑后继续后续代码；无匹配`catch`时，按嵌套规则查找，仍无则调用`terminate()`，进而调用`abort()`终止程序；
3. 嵌套异常处理：`try`块中可嵌套`try-catch`，内层异常优先由内层`catch`处理，未捕获则向外层传播；
4. 注意事项：异常处理可能导致内存泄漏，需使用智能指针（`shared_ptr`/`unique_ptr`）管理动态内存；
5. 断言（assertion）：

      - 宏`assert`定义在`<cassert>`或`<assert.h>`中，格式为`assert(<表达式>)`，`<表达式>`通常为关系/逻辑表达式；
      - 执行逻辑：表达式为`true`时程序继续；为`false`时，输出表达式、源文件名、行号等诊断信息，调用`abort()`终止程序；
      - 原理：调试模式下（未定义`NDEBUG`）生效，release模式下（定义`NDEBUG`）自动失效，仅用于调试时的逻辑检查。

## 8. 泛型与函数式程序设计
### 8.1 泛型程序设计
1. 核心概念：编写与类型无关的通用代码，实现类型安全的代码复用，核心技术是模板；
2. 模板分类：函数模板（通用函数）、类模板（通用类）；
3. 模板复用问题：频繁实例化可能导致代码膨胀（每个类型生成独立代码），可通过显式实例化优化。

### 8.2 STL
STL（标准模板库）是泛型程序设计的典型实现，包含容器（存储数据，如`vector`、`map`）、算法（操作数据，如`sort`、`find`）、迭代器（连接容器与算法）等组件，简化通用代码编写。

### 8.3 函数式程序设计
1. 命令式vs函数式：命令式关注“如何做”（步骤化指令，强调状态变化）；函数式关注“做什么”（函数组合，强调无副作用）；
2. 定义：以函数为核心，函数是一等公民（可作为参数、返回值），依赖纯函数（输入决定输出，无副作用）；
3. 基本手段：函数指针、仿函数（函数对象）、lambda表达式、STL算法（支持函数作为参数）。

