# C++总复习

## 2. 对象与类

### 2.1 对象与类的基本定义

**对象**：类的实例，是具有属性（数据成员）和行为（成员函数）的具体实体。

**类**：对象的抽象模板，定义了对象共有的数据成员和成员函数，规定了对象的属性和行为。

**成员访问修饰符**：

- `public`：公有权限，类内外均可访问。
- `private`：私有权限，仅类内（含友元）可访问。
- `protected`：保护权限，类内（含友元）及子类可访问。

**对象的创建与销毁**：

- 创建动态数组对象：`A* p = new A[100];`（分配100个A类对象的连续内存）。
- 销毁动态数组对象：`delete[] p;`（必须用`delete[]`匹配`new[]`，避免内存泄漏）。

**成员对象**：一个类的成员可以是另一个类的对象（嵌套对象），称为成员对象。

**对象的操作机制**：对象的行为通过向对象发送消息（调用成员函数）实现。

### 2.2 this指针

**核心特性**：

- 每个非静态成员函数都隐含一个`this`指针参数，指向当前调用该函数的对象。
- 数据成员为每个对象单独拥有拷贝；静态成员函数无`this`指针，所有对象共享，仅能访问静态成员。

**this指针的使用场景**：

- 区分成员变量与局部变量（如`this->x = x`）。
- 从成员函数中返回当前对象（`return *this`）。
- 作为参数传递给其他函数（传递当前对象的地址）。

### 2.3 构造函数与析构函数

**构造函数的基本规则**：

- 函数名与类名相同，无返回值（无需写`void`）。
- C++11前不允许在类内直接初始化数据成员（如`int x=0;`不允许），需通过构造函数或初始化表赋值。

**默认构造函数**：

- 无参数或所有参数都有默认值的构造函数（如`A()`、`A(int a=0)`）。
- 若未自定义构造函数，编译器会自动生成默认构造函数；若自定义了任意构造函数，编译器不再生成。
- 调用方式：`A a1;`（无参）、`A a2 = A();`（显式无参）、`new A`（动态对象）、`new A(2)`（带参构造）。

**常成员与引用成员的初始化**：

- `const`修饰的常数据成员、引用数据成员，不能在声明时初始化，也不能在构造函数体内部赋值。
- 必须在**成员初始化表**中完成初始化（如`A(const int& val) : x(val), ref(val) {}`）。

**成员初始化表的注意事项**：

- 初始化顺序不依赖初始化表中的书写顺序，最终由数据成员在类中的**声明顺序**决定。
- 语法格式：`类名(参数列表) : 成员1(初值1), 成员2(初值2), ... {}`。

**析构函数**：

- 函数名前加`~`，与类名相同，无参数、无返回值，一个类仅有一个析构函数。
- 核心作用：释放对象生命周期中额外申请的资源（如动态内存、文件句柄等）。
- 可主动调用（如`a.~A();`），此时暂时归还资源，但对象未被销毁，生命周期仍持续到作用域结束。

**成员对象的初始化与销毁次序**：

- 初始化：先调用**成员对象的构造函数**（按成员对象在本类中的声明顺序），再执行本类的构造函数体。
- 销毁：先执行本类的析构函数体，再调用**成员对象的析构函数**（按成员对象声明顺序的逆序）。

### 2.4 对象的拷贝与转移初始化

#### 拷贝构造函数

**定义格式**：`A(const A& a)`（参数为同类对象的常量引用，避免递归调用）。

**三种调用时机**：

- 创建对象时，显式用另一个同类对象初始化：`A a2(a1);` 或 `A a2 = a1;`。
- 对象作为**值参数**传递给函数：`void f(A x)`（调用`f(a1)`时，用`a1`拷贝构造`x`）。
- 函数返回值为对象（值返回）：`A f() { A temp; return temp; }`（用`temp`拷贝构造返回的临时对象）。

**隐式拷贝构造函数**：

- 若未自定义拷贝构造函数，编译器会自动生成隐式拷贝构造函数。
- 对非成员对象：按字节拷贝（浅拷贝）数据成员。
- 对成员对象：调用成员对象的拷贝构造函数完成初始化。

**浅拷贝的问题**：

- 当类包含指针成员时，浅拷贝仅复制指针地址，而非指针指向的资源。
- 导致多个对象共享同一块资源，析构时会重复释放，引发内存泄漏或程序崩溃。

**深拷贝**：

- 自定义拷贝构造函数，为指针成员重新分配内存，并复制资源内容（如`A(const A& a) { this->ptr = new int(*a.ptr); }`）。
- 解决浅拷贝的资源共享问题，确保每个对象拥有独立的资源。

**自定义拷贝构造函数的注意事项**：

- 自定义拷贝构造函数不会自动调用成员对象的拷贝构造函数。
- 必须在自定义拷贝构造函数的**成员初始化表中显式指定**（如`A(const A& a) : member(a.member) {}`）。

**拷贝构造函数的潜在问题**：

- 当用一个即将被销毁的临时对象初始化另一个同类对象时，自定义拷贝构造函数的效率较低（需拷贝资源）。

**返回值优化（RVO）**：

- 编译器优化技术，针对"函数值返回对象"的场景（第三种调用时机）。
- 直接在调用者的栈帧中创建目标对象，避免临时对象的创建和拷贝，提升效率。
- 优化后不执行拷贝构造函数，直接将函数内的对象资源转移到调用者对象中。

**移动构造函数**：

- 解决临时对象拷贝效率低的问题，语法格式：`A(A&& a)`（参数为右值引用）。
- 编译器不会提供隐式移动构造函数，需手动定义。
- 核心逻辑："窃取"右值对象（临时对象）的资源，而非拷贝，右值对象后续会被析构，不影响程序安全。

**关键工具与概念**：

- `std::move`：将左值转换为右值引用，使左值对象可被移动构造函数使用（如`A a2 = std::move(a1);`）。
- 左值vs右值：左值是可取地址、能被赋值的对象（如变量`a1`）；右值是临时对象、字面量（如`A()`、`10`），不可取地址。

### 2.5 常成员与静态成员

#### 常成员

**常成员函数**：

- 声明格式：`返回值类型 函数名(参数列表) const;`（`const`在函数名后）。
- 核心限制：不能修改类的非静态数据成员，也不能调用非`const`的成员函数。
- 常对象（`const A a;`）只能调用类中的常成员函数；非`const`对象既可调用常成员函数，也可调用非`const`成员函数。

**常数据成员**：

- 声明格式：`const 数据类型 成员名;`（如`const int x;`）。
- 必须在成员初始化表中初始化，初始化后不可修改。

#### 静态成员

**静态数据成员**：

- 声明格式：`static 数据类型 成员名;`（类内声明）。
- 必须在**类外定义并初始化**（类外定义时不加`static`，需加类名限定符），如`int A::count = 0;`。
- 所有对象共享该成员，生命周期与程序一致（早于对象创建，晚于对象销毁）。

**静态成员函数**：

- 声明格式：`static 返回值类型 函数名(参数列表);`。
- 无`this`指针，仅能访问类的静态成员（静态数据成员、静态成员函数），不能访问非静态成员。
- 调用方式：`类名::函数名()`（推荐）或`对象.函数名()`。

### 2.6 友元

**定义与作用**：

- 友元是类授予的一种特殊访问权限，被声明为友元的实体（函数、类）可访问类的`private`和`protected`成员。
- 声明格式：在类内用`friend`关键字声明（如`friend void f(A& a);`、`friend class B;`）。

**友元的特性**：

- 友元关系是单向的（A是B的友元，不代表B是A的友元）。
- 友元关系不可传递（A是B的友元，B是C的友元，不代表A是C的友元）。
- 友元不具有继承性（子类不会继承父类的友元关系）。

### 2.7 类作为模块

**模块的定义**：类是面向对象中的基本模块，封装了数据（属性）和操作（行为），实现"高内聚、低耦合"。

**类结构与子结构**：类的结构直接对应模块的结构，成员对象可视为模块的子模块。

**良好的面向对象程序设计风格**：

- 减少类之间的关联度（低耦合），类内部高度聚合（高内聚）。
- 迪米特法则（Demeter's Law）：一个类的成员函数只能访问以下对象：
  - 自身对象（`this`指向的对象）。
  - 函数参数传递的对象。
  - 成员对象。
  - 函数内创建的局部对象。
  - 仅应向上述有限集合中的对象发送消息（调用成员函数），避免过度依赖其他对象。

## 3. 操作符重载

### 3.1 操作符重载的基本规则

**定义格式**：

- 成员函数形式：`返回值类型 operator操作符(参数列表) const;`（如`A operator+(const A& x) const;`）。
- 全局函数形式：`friend 返回值类型 operator操作符(参数列表);`（需声明为友元以访问类私有成员）。

**重载限制**：

- 不能重载的操作符：`.`、`.*`、`::`、`? :`、`sizeof`、`typeid`等。
- 作为全局函数重载时，至少有一个参数是类、结构、枚举或其引用（避免重载基本数据类型的操作符，如`int+int`）。
- 运算符`+=`等复合赋值运算符，建议用成员函数重载；`+`等二元运算符，可根据需求选择成员函数或全局函数。

**下标操作符`[]`重载**：

- 需重载两个版本（支持普通对象和常对象）：
  - 普通版本：`int& operator[](int i);`（可修改对象成员）。
  - 常版本：`int operator[](int i) const;`（常对象调用，不可修改）。

**单目操作符重载**：

- 负号`-`重载（成员函数形式）：`A operator-() const;`（如`A b = -a;`）。

**自增`++`与自减`--`重载**：

- 前置版本（无参数）：`A& operator++();`（返回引用，支持链式操作，如`++(++a)`）。
- 后置版本（参数为`int`，仅作为区分标记）：`const A operator++(int);`（返回临时对象，不支持链式自增，如`(a++)++`无效）。

**自定义类型转换操作符**：

- 定义格式：`operator 目标类型() const;`（如`operator int() const;`，支持`A a; int x = a;`的隐式转换）。

**`explicit`关键字**：

- 用于修饰单参数构造函数或类型转换操作符，禁止隐式类型转换。
- 示例：`explicit A(int x) {}`（禁止`A a = 5;`，仅允许`A a(5);`显式构造）；`explicit operator int() const;`（禁止`int x = a;`，仅允许`int x = static_cast<int>(a);`显式转换）。

### 3.2 赋值操作符重载

**核心问题**：与浅拷贝类似，若类包含指针成员，默认赋值操作符（编译器自动生成）会执行浅拷贝，导致资源共享问题。

**自定义赋值操作符的注意事项**：

- 若类包含成员对象，自定义赋值操作符不会自动调用成员对象的赋值操作符，需显式调用（如`this->member = a.member;`）。
- 需处理自赋值情况（`a = a;`），避免资源释放后再访问（如`delete ptr; ptr = new int(*a.ptr);`前需判断`this != &a`）。

**拷贝与赋值的区别**：

- 拷贝：创建新对象时用已有对象初始化（调用拷贝构造函数），如`A b = a;`、`A b(a);`。
- 赋值：已有对象之间的赋值操作（调用赋值操作符），如`A b; b = a;`。

**移动赋值操作符**：

- 定义格式：`A& operator=(A&& a);`（参数为右值引用）。
- 核心逻辑：窃取右值对象的资源，避免拷贝，提升效率（如`A b = std::move(a);`）。

### 3.3 函数对象（仿函数）

**定义**：重载了`()`操作符的类的对象，具备函数调用的特性。

**核心原理**：`()`的重载本质是操作符重载，函数对象的调用其实是调用`operator()`。

**使用场景**：

- 作为算法的参数（如STL算法`sort`的比较函数）。
- 封装带状态的函数逻辑（函数对象可包含数据成员，记录状态）。

**实现步骤**：

- 定义一个类，重载`operator()`成员函数（参数对应函数的参数，返回值对应函数的返回值）。
- 创建该类的对象（普通对象或临时对象）。
- 用"对象名(参数列表)"的形式调用（如`MyFunc f; f(10);`或`MyFunc()(10);`）。

**示例场景**：

- 定义一个类，数据成员对应表达式中用到的环境变量（如系数、阈值等）。
- 重载`()`操作符，实现表达式计算逻辑（如`class Add { int val; public: Add(int v) : val(v) {} int operator()(int x) { return x + val; } };`）。
- 创建临时对象并调用：`int res = Add(5)(3);`（结果为8）。

### 3.4 TODO

