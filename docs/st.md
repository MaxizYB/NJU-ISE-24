# 软件测试复习笔记
## 一、软件测试基础
### 1. 测试基础要素
1. 测试用例：包含测试输入、执行条件、预期结果和实际结果的文档化描述
2. 测试报告：包含测试概要、测试用例执行情况、缺陷统计和分析结论四部分
3. 软件测试标准：遵循ISO/IEC/IEEE 29119软件测试系列标准

### 2. 常用测试分类
| 测试层级 | 具体类型 |
|----------|----------|
| 单元测试 | 针对软件最小功能单元的测试 |
| 集成测试 | 验证组件间协作能力的测试 |
| 系统测试 | 对完整系统功能、性能等的全面测试 |
| 验收测试 | 确认软件是否满足用户需求的测试 |

| 测试维度 | 具体类型 |
|----------|----------|
| 功能测试 | 验证软件功能是否符合需求 |
| 性能测试 | 测试软件响应速度、并发能力等 |
| 安全测试 | 检测软件安全漏洞、数据保护能力 |
| 兼容性测试 | 验证软件在不同环境下的运行情况 |
| 易用性测试 | 评估用户使用软件的便捷性 |

### 3. 测试分析框架
测试分析框架是一套用于指导测试过程中分析需求、设计用例、评估结果的结构化方法，核心包含需求分析、风险识别、测试范围界定、用例设计依据、结果评估指标等模块，用于确保测试的全面性和针对性。

### 4. 不同程序下的测试数据（文档）
测试数据需根据程序类型、功能场景设计，包括有效数据、无效数据、边界数据等，文档需记录数据来源、用途、预期结果，确保测试可复现。例如，对于一个登录程序，需要设计有效用户名密码、无效用户名、错误密码、边界长度字符串等测试数据。

## 二、BUG理论
### 1. PIE模型

1. **Defect（缺陷）**：静态存在于程序中的问题，是错误的根源
2. **故障连续性**：选择5个测试距离较远的用例，距离计算方法包括：

   - 欧氏距离：√Σ(xi-yi)²
   - 曼哈顿距离：Σ|xi-yi|
   - 余弦距离：1 - (x·y)/(|x|·|y|)
   - 汉明距离：两个等长字符串对应位置不同字符的个数
   - 编辑距离：将一个字符串转换为另一个字符串所需的最少操作次数

### 2. 引导性随机测试

1. **核心**：选择随机测试生成方法，快速生成覆盖程序路径的测试用例
2. **相关技术**：

   - 基于执行轨迹的测试方法
   - 符号求解：通过变量符号化分析程序路径，但存在状态爆炸问题（变量增多时路径数量呈指数增长）

### 3. 软件等价类划分

1. **定义**：等价类指输入域的一个子集，该子集中各个输入对于揭露软件中的缺陷所起作用等价
2. **划分思路**：

   - 确定输入和输出范围
   - 划分等价类并选择代表性测试用例
3. **等价类分类**：

   - **输入等价类**：

     - 有效等价类：符合需求的输入（如年龄输入18-60）
     - 无效等价类：不符合需求的输入（如年龄输入-5或200）
   - **输出等价类**：

     - 有效等价类：符合预期的输出
     - 无效等价类：不符合预期的输出
     - 未指定等价类：需求未明确说明的输出
4. **等价类测试策略**：

   - **弱一般等价类测试**：取各变量有效等价类的单个代表值
   - **强一般等价类测试**：覆盖所有有效等价类的笛卡尔积组合
   - **弱健壮性测试**：单缺陷原则，每次仅引入一个无效等价类
   - **强健壮性测试**：覆盖所有有效与无效等价类的组合

### 4. 划分随机测试

1. **定义**：将输入域划分为K个子域，每个子域的选择概率为Pi
2. **相关度量**：

   - **P-度量**：测试集至少包含一个子域测试用例的概率
     - 示例：若输入域划分为3个子域，每个子域Pi=1/3，简单随机测试中P(a)=1-(2/3)^n
   - **简单随机**：Pi=1/K（K为子域总数）
   - **E-度量**：测试集触发软件故障的期望次数，E=n×p
     - 示例：若p=0.05，n=20，则E=1，即期望触发1次故障
   - **F-度量**：检测缺陷的概率度量，遵循几何分布
     - 几何分布公式：P(X=k)=(1-p)^(k-1)×p
   - **平均无故障时间（MTTF）**：总运行时间/故障次数

### 5. 变异缺陷

1. **相关假设**：

   - **熟练程序员假设**：熟练程序员编写的代码缺陷较少，且多为简单缺陷
   - **耦合效应假设**：检测简单缺陷的测试用例也能检测出复杂缺陷
2. **变异体**：对原程序按照合法语法规则进行微小修改后的版本
3. **变异体检测**：通过执行测试用例，对比原程序与变异体的输出结果
4. **变异分数**：杀死的变异体数量/总变异体数量
5. **变异算子**：

   - 值变异：修改变量赋值
   - 语句变异：增删改语句
   - 决策变异：修改判断条件
6. **杀死变异体**：

   - **强杀死**：原程序与变异体的中间执行结果和最终输出均不同
   - **弱杀死**：仅最终输出不同

### 6. 变异测试的技术
1. **变异选择优化流程**：生成变异体→执行测试用例→判断是否杀死变异体→保留有效变异体
2. **变异体选择策略**：

   - **内部变异体随机测试**：随机选择部分内部变异体进行测试
   - **变异体聚类抽样**：将相似变异体聚类，从每个聚类中抽样测试

### 7. 逻辑测试基础
1. **逻辑故障假设**：程序中因逻辑错误导致的功能异常
2. **逻辑故障分类**：

   - **0/1固化故障**：变量值被错误地固定为0或1
   - **文字非故障**：逻辑表达式中变量的否定符号使用错误
3. **逻辑测试策略**：基于逻辑表达式的覆盖准则设计测试用例
4. **逻辑故障与逻辑结构的关系**：逻辑结构越复杂，逻辑故障的隐蔽性越强

## 三、组合测试
### 1. 基本概念
1. **核心要素**：

   - 参数（输入变量）
   - 取值（每个参数的可选值）
   - 组合强度（k-因素组合）：k=2时为两两组合，k=3时为三三组合
2. **示例**：若参数A（取值1、2）、B（取值a、b），k=2，则需覆盖组合（1,a）、（1,b）、（2,a）、（2,b）

### 2. 组合测试生成
1. **覆盖集定义**：CA(N;k,m,v)

   - N为测试用例数量（行数）
   - k为组合强度
   - m为参数数量
   - v为每个参数的取值数
   - 示例：CA(4;2,2,2)表示4个测试用例，2因素组合，2个参数，每个参数2个取值
2. **贪心生成算法**：

   - **目标**：生成最小的测试用例集覆盖所有k-组合
   - **流程**：初始化未覆盖集U→选择覆盖U中最多未覆盖组合的测试用例→更新U→重复直至U为空

## 四、故障假设测试
### 1. 边界故障假设
1. **正向边界故障假设**：U∈[min, max-1]，检测最大值边界的异常
2. **负向边界故障假设**：U∈[min+1, max+1]，检测最小值和最大值外的边界异常
3. **完整边界故障假设**：U∈[min-1, max+1]，覆盖六个边界点
4. **示例**：若参数取值范围为[10, 20]，则边界测试用例为9、10、11、19、20、21

### 2. 白盒边界故障假设
1. **白盒边界类型**：

   - 循环边界（循环次数的最小值、最大值）
   - 分支判定边界（判断条件的临界值）
   - 数据结构边界（数组的下标边界、字符串的长度边界）
2. **边界取值**：min-1、min、min+1、max-1、max、max+1

## 五、图分析测试
### 1. 图基础概念
1. **测试图定义**：G=(V,E,L)

   - V为顶点集（包含起始顶点S、终结顶点T）
   - E为边集（表示顶点间的转移关系）
   - L为边的标签（表示转移条件或操作）

### 2. 控制流图（CFG）
1. **定义**：以程序语句为节点，以语句间的执行顺序为边的图
2. **生成方法**：

   - 识别程序中的基本块（连续执行的语句块，无分支）
   - 以基本块为节点
   - 按照语句执行顺序连接节点，形成边

### 3. 数据流图（DFG）
1. **节点含义**：代表对数据对象的定义操作（赋值）或引用操作（取值）

### 4. 事件流图
1. **定义**：包含事件集和事件间的转移关系，节点表示事件，边表示事件的触发顺序

### 5. L-路径测试
1. **核心思想**：将程序转化为图，通过覆盖准则约束测试用例需覆盖的路径结构
2. **覆盖准则**：

   - **VC（顶点覆盖）**：覆盖所有顶点
   - **EC（边覆盖）**：覆盖所有边
   - **LC（长度覆盖）**：覆盖所有长度为L的路径
   - **覆盖层级关系**：VC < EC < LC

### 6. 主路径测试
1. **相关概念**：

   - **简单路径**：路径中没有重复顶点的路径
   - **主路径**：极大化简单路径（无法在不重复顶点的前提下延长的简单路径）
2. **主路径覆盖准则**：覆盖所有主路径

### 7. 基本路径测试
1. **基本路径**：线性独立的路径集合
2. **环路复杂度（V(G)）**：V(G)=E - V + 2（E为边数，V为顶点数）
3. **基本路径生成方法**：图元素测试法

### 8. 数据流测试
1. **核心概念**：

   - **定义（def）**：程序中变量值被赋值或更新的语句
   - **引用（use）**：程序中变量值被读取或使用的语句
   - **定义清晰路径（DU路径）**：变量从定义到引用的路径中，没有被重新定义
2. **覆盖准则**：

   - **ADC（定义覆盖）**：覆盖所有变量的定义
   - **AUC（引用覆盖）**：覆盖所有变量的引用
   - **ADUPC（定义-引用路径覆盖）**：覆盖所有变量的定义-引用路径

### 9. 逻辑覆盖
1. **语句覆盖（SC）**：设计测试用例，使程序中每个语句至少执行一次
2. **判定覆盖（DC）**：设计测试用例，使程序中每个判断条件的真假值至少执行一次
3. **条件覆盖（CC）**：设计测试用例，使判断条件中的每个子条件的真假值至少执行一次
4. **判定-条件覆盖（DCC）**：同时满足判定覆盖和条件覆盖
5. **修正条件判定覆盖（MCDC）**：每个子条件的变化独立影响判断条件的结果

## 六、开发者测试
### 1. 单元测试
1. **测试对象**：软件的最小功能单元（如函数、方法、类）
2. **测试重点**：模块内部的逻辑、接口、数据结构
3. **依赖隔离技术**：

   - **Mock**：模拟依赖模块的行为，返回预设结果
   - **Stub**：简化依赖模块的实现，仅提供必要的接口
4. **单元测试原则**：尽早测试、自动化、简单性、高质量

### 2. 接口测试
1. **定义**：针对软件系统中接口（如API）的测试，验证接口的功能、性能、安全性、兼容性
2. **测试内容**：

   - API性能测试：响应时间、并发处理能力、吞吐量
   - API安全性测试：权限控制、数据加密、防注入攻击
   - API兼容性测试：不同版本、不同环境下的兼容性
   - 接口监视：实时监控接口运行状态
   - 接口覆盖：覆盖所有参数组合、请求方法
   - 响应状态码：验证状态码是否符合规范
   - 多API组合测试：测试接口协同工作
   - 正向/负向测试：合法请求vs非法请求
   - 持续集成（CI）：集成到CI流程中

### 3. 集成测试
1. **测试时机**：单元测试完成后
2. **测试目的**：验证软件组件间的协同工作能力
3. **集成方法**：

   - **自顶向下集成**：从顶层组件开始，逐步集成下层组件（需使用Stub）
   - **自底向上集成**：从底层组件开始，逐步集成上层组件（需使用Mock）
   - **混合集成**：结合自顶向下和自底向上
   - **一次性集成**：所有组件开发完成后一次性集成

### 4. 多样性验证测试
1. **核心**：基于代码多样性设计测试用例，包括变异测试、随机测试
2. **测试优势**：覆盖更多潜在缺陷，避免单一测试方法的局限性
3. **测试粒度**：方法级、模块级、系统级

### 5. 故障假设开发者测试
1. **边界定义**：明确被测对象的输入、输出、逻辑边界
2. **变异修改**：修改程序代码中的变量值、语句、参数、返回值等
3. **测试分类器**：T×P（测试用例集与程序版本的组合）

## 七、功能测试
### 1. 传统功能测试
1. **测试流程**：明确功能需求→设计测试用例→执行测试用例→验证测试结果

### 2. 多样性功能测试
1. **等价类划分**：确保划分的等价类完备（覆盖所有输入场景）、无冗余
2. **结果分析**：通过分析测试结果，评估功能覆盖度和缺陷分布
3. **测试评估**：使用覆盖率等指标评估测试效果

### 3. 故障假设功能测试
1. **测试流程**：制定测试规划→设计故障变异算子→执行测试→分析测试结果
2. **变异强度**：根据测试需求调整变异的复杂程度

## 八、性能测试
### 1. 基本概念
1. **定义**：测试软件在特定条件下的性能指标
2. **常见类型**：

   - **并发测试**：测试软件在多用户同时操作下的性能
   - **负载测试**：逐步增加负载，测试软件的性能变化趋势
   - **压力测试**：超过设计负载的极限测试

### 2. 多样性性能测试
1. **测试变量**：负载强度、网络条件、软硬件配置
2. **测试目的**：验证软件在不同环境下的性能稳定性

### 3. 故障假设性能测试
1. **故障变异算子**：模拟性能相关的故障
2. **测试重点**：软件在故障场景下的性能衰减趋势、恢复能力

## 九、适配测试
### 1. 基本概念
1. **定义**：测试软件在不同硬件、操作系统、浏览器、数据库等环境下的兼容性
2. **核心目标**：确保软件在目标环境中正常运行

### 2. 信创适配测试的关注点及原则
1. **关注点**：硬件适配、软件适配、协议适配
2. **原则**：国产化替代优先、兼容性全面覆盖、性能达标、安全合规

### 3. 多样性适配测试
1. **测试环境组合**：不同硬件配置×不同软件版本×不同网络环境

### 4. 故障假设适配测试
1. **测试场景**：模拟环境异常，测试软件的适配稳定性

### 5. 适配测试重点方向
| 产品类型 | 测试重点 |
|----------|----------|
| 云平台软件 | 虚拟化兼容性、资源调度适配、多租户隔离适配 |
| 应用软件 | 操作系统适配、浏览器适配、数据库适配 |
| 外设产品 | 硬件驱动适配、数据传输适配 |
| 网络产品（交换机） | 协议适配、带宽适配、多设备互联适配 |
| 存储产品 | 接口适配、数据读写适配、兼容性（与服务器、数据库） |
| 基础软件（操作系统、数据库） | 硬件适配、应用程序适配、API兼容性 |
| 整机产品（移动设备、PC） | 硬件配置适配、系统固件适配、外设连接适配 |

## 十、模糊测试
### 1. 基本概念
1. **定义**：通过向被测程序（PUT）输入随机、无效、畸形的数据，检测程序是否存在崩溃、漏洞等问题
2. **三要素**：一套模糊测试工具（Fuzzer）、一个测试目标（PUT）、一个测试循环（Fuzzing Loop）

### 2. 整体流程
Inputs（输入数据）→ Fuzzer（生成畸形测试用例）→ Execute Program（执行被测程序）→ Crash Triage（崩溃分析）→ Results（输出测试结果）

### 3. 关键设计
1. **变异算子设计**：生成畸形数据的规则（如字符替换、长度篡改、格式破坏）
2. **有效反馈设计**：实时监控程序运行状态（如崩溃、超时、内存溢出）

## 十一、测试用例优先级
1. **优先级定义**：根据测试用例的缺陷检测概率、执行成本等因素，确定测试用例的执行顺序
2. **优先级算法**：

   - **贪心算法**：优先选择覆盖未测试场景最多的测试用例
   - **自适应随机算法**：根据历史测试结果，动态调整测试用例的选择概率
3. **优先级评估流程**：提取被测程序特征→表示特征向量→分析已有测试用例集→计算测试用例优先级→排序测试用例
4. **评价指标**：

   - **缺陷检测率**：优先级高的用例检测到的缺陷数/总缺陷数
   - **平均检测时间**：首次检测到缺陷的平均时间
